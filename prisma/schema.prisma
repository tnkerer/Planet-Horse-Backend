// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = []
  engineType      = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String              @id @default(uuid())
  wallet               String              @unique
  name                 String?
  horses               Horse[]
  breeds               Breed[]
  items                Item[]
  transactions         Transaction[]
  chests               Chest[]
  requests             BridgeRequest[]
  itemRequests         ItemBridgeRequest[]
  mintRequests         HorseMintRequest[]
  burnRequests         BurnRequest[]
  stableSale           StableSale?
  stable               Stable[]
  stableMintRequest    StableMintRequest[]
  createdAt            DateTime            @default(now())
  updatedAt            DateTime?           @updatedAt
  phorse               Float               @default(0)
  wron                 Float               @default(0)
  shards               Int                 @default(0)
  medals               Int                 @default(0)
  totalPhorseEarned    Float               @default(0)
  totalPhorseSpent     Float               @default(0)
  presalePhorse        Float               @default(0)
  lastRace             DateTime?
  // Discord linking
  discordId            String?             @unique
  discordTag           String?
  score                Score?
  // Referral System
  refCode              String?             @unique
  referredById         String?
  referredBy           User?               @relation("UserReferrals", fields: [referredById], references: [id])
  referrals            User[]              @relation("UserReferrals")
  // Referral Levels
  xp                   Int                 @default(0)
  referralLevel        Int                 @default(1)
  referralPhorseEarned Float               @default(0)
  // Upgrade Score
  upgradeScore         Int                 @default(0)
  burnScore            Int                 @default(0)

  // Stables
  leases       StableLease[]
  careerfactor Float         @default(1)
}

model ReferralXPLog {
  id          String   @id @default(uuid())
  referrerId  String
  refereeId   String
  phorseSpent Float
  createdAt   DateTime @default(now())
}

model Nonce {
  id        Int      @id @default(autoincrement())
  address   String
  nonce     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model Horse {
  id            String         @id @default(uuid())
  tokenId       String         @unique
  owner         User           @relation(fields: [ownerId], references: [id])
  ownerId       String
  name          String
  nickname      String?        @unique
  sex           Sex
  status        Status
  rarity        String
  exp           Int
  upgradable    Boolean
  level         Int
  basePower     Int
  currentPower  Int
  baseSprint    Int
  currentSprint Int
  baseSpeed     Int
  currentSpeed  Int
  currentEnergy Int
  maxEnergy     Int
  foodUsed      Int            @default(0)
  equipments    Item[]
  lastRace      DateTime?
  lastEnergy    DateTime?
  lastBreeding  DateTime?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime?      @updatedAt
  raceHistory   RaceHistory[]
  presaleIntent PresaleIntent? @relation(fields: [intentId], references: [id])
  intentId      String?
  gen           Int            @default(0)
  currentBreeds Int            @default(0)
  ownedSince    DateTime?
  maxBreeds     Int?

  // NEW: how many trait slots this horse may fill now (2..5)
  traitSlotsUnlocked Int @default(2)

  // NEW: relation to the per-horse trait rows
  traits  HorseTrait[]
  parents Int[]

  // Level up ticket utils
  usedLevelUpTicket Boolean @default(false)

  // Stable
  stable              Stable?   @relation(fields: [stableid], references: [id])
  stableid            String?
  lastStableAsignment DateTime?

  careerfactor Float @default(1)

  @@index([ownerId])
}

model Breed {
  id        String    @id @default(uuid())
  owner     User      @relation(fields: [ownerId], references: [id])
  ownerId   String
  parents   Int[]
  tokenId   Int?
  started   DateTime?
  finalized Boolean
}

model Item {
  id        String    @id @default(uuid())
  owner     User      @relation(fields: [ownerId], references: [id])
  ownerId   String
  equipedBy Horse?    @relation(fields: [horseId], references: [id])
  horseId   String?
  name      String
  value     Int
  breakable Boolean
  uses      Int?
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

model Transaction {
  id        String            @id @default(uuid())
  owner     User              @relation(fields: [ownerId], references: [id])
  ownerId   String
  type      TransactionType
  status    TransactionStatus
  value     Float
  note      String?
  txId      String?
  request   BridgeRequest?
  createdAt DateTime          @default(now())
  updatedAt DateTime?         @updatedAt

  tokenAddress String?
  tokenSymbol  String?
  tokenId      Int?

  // For DEPOSIT rows we set (txId, type, tokenAddress), making duplicates impossible:
  @@unique([txId, type, tokenAddress])
  @@index([tokenAddress])
}

model Chest {
  id        String @id @default(uuid())
  owner     User   @relation(fields: [ownerId], references: [id])
  ownerId   String
  chestType Int
  quantity  Int

  @@unique([ownerId, chestType])
}

model BridgeRequest {
  id            String      @id @default(uuid())
  owner         User        @relation(fields: [requesterId], references: [id])
  requesterId   String
  request       Request
  value         Float
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  transactionId String      @unique
  createdAt     DateTime    @default(now())

  tokenSymbol  String?
  tokenAddress String?

  @@index([tokenSymbol])
  @@index([tokenAddress])
}

model ItemBridgeRequest {
  id          String            @id @default(uuid())
  owner       User              @relation(fields: [requesterId], references: [id])
  requesterId String
  request     Request
  quantity    Int
  tokenId     Int
  txId        String?
  status      TransactionStatus
  createdAt   DateTime          @default(now())
  updatedAt   DateTime?         @updatedAt
}

model HorseMintRequest {
  id          String            @id @default(uuid())
  owner       User              @relation(fields: [requesterId], references: [id])
  requesterId String
  tokenId     Int
  txId        String?
  status      TransactionStatus
  createdAt   DateTime          @default(now())
  updatedAt   DateTime?         @updatedAt
}

enum TraitTier {
  COMMON
  RARE
  MYTHIC
}

model TraitCatalog {
  id          Int          @id // 1..10 (Racecraft, Iron Hooves, ...)
  name        String       @unique
  // add a "key" if you like (e.g., "racecraft")
  HorseTraits HorseTrait[]
}

model HorseTrait {
  id      String @id @default(uuid())
  horse   Horse  @relation(fields: [horseId], references: [id], onDelete: Cascade)
  horseId String

  // slot 1..5, unique per horse
  slot Int

  // which trait and tier
  trait   TraitCatalog @relation(fields: [traitId], references: [id])
  traitId Int
  tier    TraitTier    @default(COMMON)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([horseId, slot]) // only one trait per slot
  @@unique([horseId, traitId]) // cannot duplicate the same trait on a horse
  @@index([horseId])
  @@index([traitId])
}

model BurnRequest {
  id          String @id @default(uuid())
  requester   User   @relation(fields: [requesterId], references: [id])
  requesterId String

  txHash       String
  tokenAddress String
  tokenId      Int
  from         String // normalized (lowercase) wallet that burned
  blockNumber  Int

  createdAt DateTime @default(now())
  // (intentionally no unique constraints per your preference)
}

enum Request {
  DEPOSIT
  WITHDRAW
  BURN
  MINT
}

enum Status {
  SLEEP
  IDLE
  BRUISED
  BREEDING
}

enum TransactionType {
  DEPOSIT
  WITHDRAW
  ITEM
  BURN
}

enum TransactionStatus {
  FAILED
  PENDING
  PROCESSING // ← new state you’re introducing
  COMPLETED
}

enum Sex {
  MALE
  FEMALE
}

model Meta {
  key   String @id
  value Int
}

model Deposit {
  id          String   @id @default(uuid())
  amount      Decimal  @db.Decimal(78, 18)
  txHash      String
  blockNumber Int
  from        String
  createdAt   DateTime @default(now())

  tokenAddress String
  tokenSymbol  String

  @@unique([txHash, tokenAddress]) // replaces the old @unique on txHash
  @@index([tokenAddress])
}

/// A historical record of each race result for a given horse
model RaceHistory {
  id           String   @id @default(uuid())
  createdAt    DateTime @default(now())
  phorseEarned Float
  xpEarned     Int
  position     Int
  horse        Horse    @relation(fields: [horseId], references: [id])
  horseId      String
  shardSpent   Float?

  @@index([horseId])
}

model PresaleIntent {
  id            String      @id @default(uuid())
  createdAt     DateTime    @default(now())
  amount        Int
  wallet        String
  status        IntentStage
  vouchedHorses Horse[]
}

enum IntentStage {
  STARTED
  PROCESSING
  DONE
  FAILED
}

model Score {
  id        String    @id @default(uuid())
  user      User      @relation(fields: [userId], references: [id])
  userId    String    @unique
  points    Int       @default(0)
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

model StableSale {
  id           String   @id @default(uuid())
  user         User     @relation(fields: [userId], references: [id])
  userId       String   @unique
  gtd          Boolean  @default(false)
  fcfs         Boolean  @default(false)
  discount     Int      @default(0)
  gtdUsed      Boolean  @default(false)
  fcfsUsed     Boolean  @default(false)
  discountList String[]
}

model StableMintRequest {
  id          String            @id @default(uuid())
  owner       User              @relation(fields: [requesterId], references: [id])
  requesterId String
  tokenId     Int
  txId        String?
  status      TransactionStatus
  createdAt   DateTime          @default(now())
  updatedAt   DateTime?         @updatedAt
}

// STABLES FEATURE
/// Which currency a listing or payment uses.
/// If OTHER, we capture tokenAddress + tokenSymbol.
enum StableRentCurrency {
  PHORSE
  WRON
  OTHER
}

enum LeaseStatus {
  PENDING
  ACTIVE
  EXPIRED
  TERMINATED // e.g., stable sold mid-week
}

enum EscrowStatus {
  HELD
  PARTIAL // some funds released/refunded
  RELEASED // fully released to owner
  REFUNDED // fully refunded to renter
}

/// Single active listing per stable.
/// Weekly price PER SLOT, owner chooses how many slots to list.
model Stable {
  id             String          @id @default(uuid())
  tokenId        String          @unique
  user           User            @relation(fields: [userId], references: [id])
  userId         String
  horses         Horse[]
  features       String[]
  stableListings StableListing[]
  stableLeases   StableLease[]
  level          Int             @default(1)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime?       @updatedAt
  upgrading      Boolean
  upgradeStarted DateTime?

  @@index([userId])
}

model StableListing {
  id       String @id @default(uuid())
  stable   Stable @relation(fields: [stableId], references: [id], onDelete: Cascade)
  stableId String @unique

  isOpen      Boolean @default(false) // discoverable in public search
  listedSlots Int     @default(0) // how many spare slots are up for rent

  currency       StableRentCurrency
  pricePerSlotWk Decimal            @db.Decimal(78, 18)

  // Only required if currency = OTHER
  tokenAddress String?
  tokenSymbol  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isOpen])
  @@index([currency])
  @@index([tokenAddress])
}

/// A 1-week lease with minimal escrow info.
/// Service computes escrowAmount = slotCount * pricePerSlotWk at creation.
model StableLease {
  id       String @id @default(uuid())
  stable   Stable @relation(fields: [stableId], references: [id], onDelete: Cascade)
  stableId String
  lessee   User   @relation(fields: [lesseeId], references: [id])
  lesseeId String

  slotCount Int

  // Snapshot the chosen payment details from the listing
  currency       StableRentCurrency
  tokenAddress   String?
  tokenSymbol    String?
  pricePerSlotWk Decimal            @db.Decimal(78, 18)

  // 1-week window (or enforce 7d in service)
  startAt DateTime
  endAt   DateTime

  status LeaseStatus @default(PENDING)

  // Minimal escrow tracking
  escrowAmount   Decimal      @db.Decimal(78, 18) // total held for the week
  escrowStatus   EscrowStatus @default(HELD)
  heldFrom       DateTime
  heldUntil      DateTime // usually = endAt
  releasedAmount Decimal      @default(0) @db.Decimal(78, 18)
  refundedAmount Decimal      @default(0) @db.Decimal(78, 18)
  terminatedAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([stableId])
  @@index([lesseeId])
  @@index([status, endAt])
}
