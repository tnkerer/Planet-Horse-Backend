// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = []
  engineType      = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String              @id @default(uuid())
  wallet               String              @unique
  name                 String?
  horses               Horse[]
  breeds               Breed[]
  items                Item[]
  transactions         Transaction[]
  chests               Chest[]
  requests             BridgeRequest[]
  itemRequests         ItemBridgeRequest[]
  mintRequests         HorseMintRequest[]
  burnRequests         BurnRequest[]
  stableSale           StableSale?
  stable               Stable[]
  stableMintRequest    StableMintRequest[]
  createdAt            DateTime            @default(now())
  updatedAt            DateTime?           @updatedAt
  phorse               Float               @default(0)
  wron                 Float               @default(0)
  shards               Int                 @default(0)
  medals               Int                 @default(0)
  totalPhorseEarned    Float               @default(0)
  totalPhorseSpent     Float               @default(0)
  presalePhorse        Float               @default(0)
  lastRace             DateTime?
  // Discord linking
  discordId            String?             @unique
  discordTag           String?
  score                Score?
  // Referral System
  refCode              String?             @unique
  referredById         String?
  referredBy           User?               @relation("UserReferrals", fields: [referredById], references: [id])
  referrals            User[]              @relation("UserReferrals")
  // Referral Levels
  xp                   Int                 @default(0)
  referralLevel        Int                 @default(1)
  referralPhorseEarned Float               @default(0)
  // Upgrade Score
  upgradeScore         Int                 @default(0)
  burnScore            Int                 @default(0)

  // Stables
  leases       StableLease[]
  careerfactor Float         @default(1)

  // Quests
  userQuests   UserQuest[]
  dailyCheckin DailyCheckin?
  PvpRaceEntry PvpRaceEntry[]
  PvpHistory   PvpHistory[]
  pvpBets      PvpBet[]
}

model ReferralXPLog {
  id          String   @id @default(uuid())
  referrerId  String
  refereeId   String
  phorseSpent Float
  createdAt   DateTime @default(now())
}

model Nonce {
  id        Int      @id @default(autoincrement())
  address   String
  nonce     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model Horse {
  id              String         @id @default(uuid())
  tokenId         String         @unique
  owner           User           @relation(fields: [ownerId], references: [id])
  ownerId         String
  name            String
  nickname        String?        @unique
  sex             Sex
  status          Status
  rarity          String
  exp             Int
  upgradable      Boolean
  level           Int
  basePower       Int
  currentPower    Int
  baseSprint      Int
  currentSprint   Int
  baseSpeed       Int
  currentSpeed    Int
  currentEnergy   Int
  maxEnergy       Int
  foodUsed        Int            @default(0)
  equipments      Item[]
  lastRace        DateTime?
  lastEnergy      DateTime?
  lastBreeding    DateTime?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime?      @updatedAt
  raceHistory     RaceHistory[]
  presaleIntent   PresaleIntent? @relation(fields: [intentId], references: [id])
  intentId        String?
  gen             Int            @default(0)
  currentBreeds   Int            @default(0)
  ownedSince      DateTime?
  maxBreeds       Int?
  legacy          Boolean        @default(false)
  growthPotential Float?

  traitSlotsUnlocked Int @default(2)

  traits  HorseTrait[]
  parents Int[]

  // Level up ticket utils
  usedLevelUpTicket Boolean @default(false)

  // Stable
  stable              Stable?   @relation(fields: [stableid], references: [id])
  stableid            String?
  lastStableAsignment DateTime?

  careerfactor Float @default(1)

  mmr          Int            @default(1000)
  PvpRaceEntry PvpRaceEntry[]
  PvpHistory   PvpHistory[]
  pvpBets      PvpBet[]

  @@index([ownerId])
}

model Breed {
  id        String    @id @default(uuid())
  owner     User      @relation(fields: [ownerId], references: [id])
  ownerId   String
  parents   Int[]
  tokenId   Int?
  started   DateTime?
  finalized Boolean
}

model Item {
  id        String    @id @default(uuid())
  owner     User      @relation(fields: [ownerId], references: [id])
  ownerId   String
  equipedBy Horse?    @relation(fields: [horseId], references: [id])
  horseId   String?
  name      String
  value     Int
  breakable Boolean
  uses      Int?
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

model Transaction {
  id        String            @id @default(uuid())
  owner     User              @relation(fields: [ownerId], references: [id])
  ownerId   String
  type      TransactionType
  status    TransactionStatus
  value     Float
  note      String?
  txId      String?
  request   BridgeRequest?
  createdAt DateTime          @default(now())
  updatedAt DateTime?         @updatedAt

  tokenAddress String?
  tokenSymbol  String?
  tokenId      Int?

  // For DEPOSIT rows we set (txId, type, tokenAddress), making duplicates impossible:
  @@unique([txId, type, tokenAddress])
  @@index([tokenAddress])
}

model Chest {
  id        String @id @default(uuid())
  owner     User   @relation(fields: [ownerId], references: [id])
  ownerId   String
  chestType Int
  quantity  Int

  @@unique([ownerId, chestType])
}

model BridgeRequest {
  id            String      @id @default(uuid())
  owner         User        @relation(fields: [requesterId], references: [id])
  requesterId   String
  request       Request
  value         Float
  transaction   Transaction @relation(fields: [transactionId], references: [id])
  transactionId String      @unique
  createdAt     DateTime    @default(now())

  tokenSymbol  String?
  tokenAddress String?

  @@index([tokenSymbol])
  @@index([tokenAddress])
}

model ItemBridgeRequest {
  id          String            @id @default(uuid())
  owner       User              @relation(fields: [requesterId], references: [id])
  requesterId String
  request     Request
  quantity    Int
  tokenId     Int
  txId        String?
  status      TransactionStatus
  createdAt   DateTime          @default(now())
  updatedAt   DateTime?         @updatedAt
}

model HorseMintRequest {
  id          String            @id @default(uuid())
  owner       User              @relation(fields: [requesterId], references: [id])
  requesterId String
  tokenId     Int
  txId        String?
  status      TransactionStatus
  createdAt   DateTime          @default(now())
  updatedAt   DateTime?         @updatedAt
}

enum TraitTier {
  COMMON
  RARE
  MYTHIC
}

model TraitCatalog {
  id          Int          @id // 1..10 (Racecraft, Iron Hooves, ...)
  name        String       @unique
  // add a "key" if you like (e.g., "racecraft")
  HorseTraits HorseTrait[]
}

model HorseTrait {
  id      String @id @default(uuid())
  horse   Horse  @relation(fields: [horseId], references: [id], onDelete: Cascade)
  horseId String

  // slot 1..5, unique per horse
  slot Int

  // which trait and tier
  trait   TraitCatalog @relation(fields: [traitId], references: [id])
  traitId Int
  tier    TraitTier    @default(COMMON)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([horseId, slot]) // only one trait per slot
  @@unique([horseId, traitId]) // cannot duplicate the same trait on a horse
  @@index([horseId])
  @@index([traitId])
}

model BurnRequest {
  id          String @id @default(uuid())
  requester   User   @relation(fields: [requesterId], references: [id])
  requesterId String

  txHash       String
  tokenAddress String
  tokenId      Int
  from         String // normalized (lowercase) wallet that burned
  blockNumber  Int

  createdAt DateTime @default(now())
  // (intentionally no unique constraints per your preference)
}

enum Request {
  DEPOSIT
  WITHDRAW
  BURN
  MINT
}

enum Status {
  SLEEP
  IDLE
  BRUISED
  BREEDING
}

enum TransactionType {
  DEPOSIT
  WITHDRAW
  ITEM
  BURN
}

enum TransactionStatus {
  FAILED
  PENDING
  PROCESSING
  COMPLETED
}

enum Sex {
  MALE
  FEMALE
}

model Meta {
  key   String @id
  value Int
}

model Deposit {
  id          String   @id @default(uuid())
  amount      Decimal  @db.Decimal(78, 18)
  txHash      String
  blockNumber Int
  from        String
  createdAt   DateTime @default(now())

  tokenAddress String
  tokenSymbol  String

  @@unique([txHash, tokenAddress]) // replaces the old @unique on txHash
  @@index([tokenAddress])
}

/// A historical record of each race result for a given horse
model RaceHistory {
  id           String   @id @default(uuid())
  createdAt    DateTime @default(now())
  phorseEarned Float
  wronEarned   Float    @default(0)
  xpEarned     Int
  position     Int
  horse        Horse    @relation(fields: [horseId], references: [id])
  horseId      String
  shardSpent   Float?
  items        String[]

  @@index([horseId])
}

model PresaleIntent {
  id            String      @id @default(uuid())
  createdAt     DateTime    @default(now())
  amount        Int
  wallet        String
  status        IntentStage
  vouchedHorses Horse[]
}

enum IntentStage {
  STARTED
  PROCESSING
  DONE
  FAILED
}

model Score {
  id        String    @id @default(uuid())
  user      User      @relation(fields: [userId], references: [id])
  userId    String    @unique
  points    Int       @default(0)
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

model StableSale {
  id           String   @id @default(uuid())
  user         User     @relation(fields: [userId], references: [id])
  userId       String   @unique
  gtd          Boolean  @default(false)
  fcfs         Boolean  @default(false)
  discount     Int      @default(0)
  gtdUsed      Boolean  @default(false)
  fcfsUsed     Boolean  @default(false)
  discountList String[]
}

model StableMintRequest {
  id          String            @id @default(uuid())
  owner       User              @relation(fields: [requesterId], references: [id])
  requesterId String
  tokenId     Int
  txId        String?
  status      TransactionStatus
  createdAt   DateTime          @default(now())
  updatedAt   DateTime?         @updatedAt
}

// STABLES FEATURE
/// Which currency a listing or payment uses.
/// If OTHER, we capture tokenAddress + tokenSymbol.
enum StableRentCurrency {
  PHORSE
  WRON
  OTHER
}

enum LeaseStatus {
  PENDING
  ACTIVE
  EXPIRED
  TERMINATED // e.g., stable sold mid-week
}

enum EscrowStatus {
  HELD
  PARTIAL // some funds released/refunded
  RELEASED // fully released to owner
  REFUNDED // fully refunded to renter
}

/// Single active listing per stable.
/// Weekly price PER SLOT, owner chooses how many slots to list.
model Stable {
  id             String          @id @default(uuid())
  tokenId        String          @unique
  user           User            @relation(fields: [userId], references: [id])
  userId         String
  horses         Horse[]
  features       String[]
  stableListings StableListing[]
  stableLeases   StableLease[]
  level          Int             @default(1)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime?       @updatedAt
  upgrading      Boolean
  upgradeStarted DateTime?

  @@index([userId])
}

model StableListing {
  id       String @id @default(uuid())
  stable   Stable @relation(fields: [stableId], references: [id], onDelete: Cascade)
  stableId String @unique

  isOpen      Boolean @default(false) // discoverable in public search
  listedSlots Int     @default(0) // how many spare slots are up for rent

  currency       StableRentCurrency
  pricePerSlotWk Decimal            @db.Decimal(78, 18)

  // Only required if currency = OTHER
  tokenAddress String?
  tokenSymbol  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isOpen])
  @@index([currency])
  @@index([tokenAddress])
}

model RewardBank {
  id        String   @id // e.g. "WRON"
  token     String   @unique // e.g. "WRON"
  available Decimal  @db.Decimal(36, 18) // how much WRON is left to distribute
  version   Int      @default(0) // optimistic-lock helper (optional)
  updatedAt DateTime @updatedAt
}

/// A 1-week lease with minimal escrow info.
/// Service computes escrowAmount = slotCount * pricePerSlotWk at creation.
model StableLease {
  id       String @id @default(uuid())
  stable   Stable @relation(fields: [stableId], references: [id], onDelete: Cascade)
  stableId String
  lessee   User   @relation(fields: [lesseeId], references: [id])
  lesseeId String

  slotCount Int

  // Snapshot the chosen payment details from the listing
  currency       StableRentCurrency
  tokenAddress   String?
  tokenSymbol    String?
  pricePerSlotWk Decimal            @db.Decimal(78, 18)

  // 1-week window (or enforce 7d in service)
  startAt DateTime
  endAt   DateTime

  status LeaseStatus @default(PENDING)

  // Minimal escrow tracking
  escrowAmount   Decimal      @db.Decimal(78, 18) // total held for the week
  escrowStatus   EscrowStatus @default(HELD)
  heldFrom       DateTime
  heldUntil      DateTime // usually = endAt
  releasedAmount Decimal      @default(0) @db.Decimal(78, 18)
  refundedAmount Decimal      @default(0) @db.Decimal(78, 18)
  terminatedAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([stableId])
  @@index([lesseeId])
  @@index([status, endAt])
}

enum QuestDifficulty {
  SIMPLE // IDs 1-9999
  MEDIUM // IDs 10000-19999
  ADVANCED // IDs 20000-29999
}

enum QuestType {
  WIN_RACES // Win X races
  RUN_RACES // Complete X races (any position)
  BREED_HORSES // Breed X horses
  LEVEL_UP_HORSES // Level up X horses
  EQUIP_ITEMS // Equip X items on horses
  OPEN_CHESTS // Open X chests
  SPEND_PHORSE // Spend X PHORSE tokens
  EARN_PHORSE // Earn X PHORSE tokens
  UPGRADE_ITEMS // Upgrade X items
  RECYCLE_ITEMS // Recycle X items
  RESTORE_ENERGY // Restore energy X times
  CLAIM_REWARDS // Claim X quest rewards
  DAILY_CHECKIN // Daily check-in
}

model Quest {
  id               Int             @id
  title            String
  description      String
  questType        QuestType // Type of quest action to track
  reward           Json // Array of {type: 'phorse'|'wron'|'medals'|'item', amount: number, itemName?: string}
  questsToComplete Int // Number of times action must be completed
  difficulty       QuestDifficulty
  isActive         Boolean         @default(true)
  isDailyQuest     Boolean         @default(false) // If true, resets daily at 00:00 UTC
  horsesToUnlock   Int             @default(0) // Minimum number of horses required to see this quest
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  userQuests       UserQuest[]
}

model UserQuest {
  id          String    @id @default(uuid())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  quest       Quest     @relation(fields: [questId], references: [id], onDelete: Cascade)
  questId     Int
  progress    Int       @default(0)
  completed   Boolean   @default(false)
  claimed     Boolean   @default(false)
  completedAt DateTime?
  claimedAt   DateTime?
  expiresAt   DateTime? // For daily quests, when they expire (next 00:00 UTC)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([userId, questId])
  @@index([userId])
  @@index([questId])
  @@index([completed, claimed])
  @@index([expiresAt])
}

model DailyCheckin {
  id            String   @id @default(uuid())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String   @unique
  lastCheckinAt DateTime
  streak        Int      @default(1)
  totalCheckins Int      @default(1)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
}

enum PvpRaceStatus {
  OPEN
  RUNNING
  COMPLETED
  CANCELLED
}

model PvpRace {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name        String
  description String?

  // Timing
  registrationOpensAt DateTime
  startsAt            DateTime

  // Constraints
  maxMmr          Int? // null = no cap
  maxParticipants Int? // null = unlimited

  // Game rules
  allowedRarities   String[]
  wronEntryFee      Float    @default(0) // per horse
  phorseEntryFee    Float    @default(0) // per horse, always burned
  wronPayoutPercent Float    @default(1) // 0..1 portion of total pot that goes to winners

  // Distribution of allocated prize (fixed per your spec)
  pctFirst  Float @default(0.5)
  pctSecond Float @default(0.35)
  pctThird  Float @default(0.15)

  status PvpRaceStatus @default(OPEN)

  entries PvpRaceEntry[]
  history PvpHistory[]

  /// --- BETTING FIELDS (NEW) ---------------------------------------------
  /// Total WRON staked in betting for this derby (all bets, before house cut)
  totalBetWron    Float    @default(0)
  /// Portion of that staking that actually forms the betting pool (80% of stakes)
  bettingPoolWron Float    @default(0)
  /// Individual bets for this race
  bets            PvpBet[]
}

model PvpBet {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  race   PvpRace @relation(fields: [raceId], references: [id], onDelete: Cascade)
  raceId String

  user   User   @relation(fields: [userId], references: [id])
  userId String

  horse   Horse  @relation(fields: [horseId], references: [id])
  horseId String

  /// Amount of WRON staked on this horse in this race
  amount Float

  /// One bet per user per horse per race (you can relax this later if you want multi-bets)
  @@unique([raceId, userId, horseId])
  @@index([raceId])
  @@index([horseId])
  @@index([userId])
}

model PvpRaceEntry {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  race   PvpRace @relation(fields: [raceId], references: [id], onDelete: Cascade)
  raceId String

  horse   Horse  @relation(fields: [horseId], references: [id])
  horseId String

  user   User   @relation(fields: [userId], references: [id])
  userId String

  // Snapshot of MMR at entry
  mmrAtEntry Int

  isActive Boolean @default(true)

  @@unique([raceId, userId]) // one horse per user per race
  @@index([raceId])
  @@index([horseId])
  @@index([userId])
}

model PvpHistory {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  race   PvpRace @relation(fields: [raceId], references: [id], onDelete: Cascade)
  raceId String

  horse   Horse  @relation(fields: [horseId], references: [id])
  horseId String

  user   User   @relation(fields: [userId], references: [id])
  userId String

  // Position in this derby
  position Int

  // MMR evolution from this derby
  mmrBefore Int
  mmrAfter  Int

  // Net WRON prize from this race (0 for losers, >0 for winners)
  wronPrize    Float @default(0)
  // PHORSE burned for this entry (logged for analytics)
  phorseBurned Float @default(0)

  @@index([raceId])
  @@index([horseId])
  @@index([userId])
  @@index([position])
}
